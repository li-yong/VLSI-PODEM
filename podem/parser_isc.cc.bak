#include "gate.h"
#include "circuit.h"
#include <iostream>
#include <fstream>
#include <cstring>
// #include <sstream>
#include <vector>
#include <sstream>
#include "hash.h"


using namespace std;


CIRCUIT Circuit;
CIRCUIT global_netlist;

unsigned no_pi=0;
unsigned no_po=0;
unsigned no_dff=0;
unsigned no_gate=0;
string name;

GATE* gptr=NULL;
GATE* inlist=NULL;

Hash<string, GATE*, Str_hash_function> NameTable;


// Function to process lines that have "nand" in the 3rd field
void proc_nand(const vector<string>& fields, const string& line2) {
    cout << "Processing NAND lines:\n";

    istringstream stream(line2);  // Create a string stream
    string nand_input;
    vector<string> inputs{};

    // Extract words separated by spaces and store them in the result vector
    while (stream >> nand_input) {
        inputs.push_back(nand_input);
    }


    vector<string> faults;

    if (fields.size() == 6){
        faults = {fields[5]};
    }else if (fields.size() == 7){
        faults = {fields[5], fields[6]}; 
    }else{
        cerr << "Erron to parse nand gate Stuck_At_Fault" << endl;
        exit(EXIT_FAILURE);
    }

    //<net_id> <identifier> <gate_type> <fanout> <fanin> <faults>
    gptr = new GATE;
    int net_id = stoi(fields[0]);
    name = fields[1]; //gate name, should be unique
    if (!NameTable.is_member(name)){
        gptr->SetName(name);
        gptr->SetFunction(G_NAND);
        gptr->Set_isc_net_id(net_id);    
        gptr->Set_isc_identifier(name);
        gptr->Set_isc_StuckAt(faults);
        gptr->Set_isc_fo_Cnt(stoi(fields[3]));
        gptr->Set_isc_fi_Cnt(stoi(fields[4]));

        // gptr->SetStuckAt(0,faults[0]=="sa0"?1:0);
        // gptr->SetStuckAt(1,faults[0]=="sa1"?1:0);
        NameTable.insert(name, gptr);
        Circuit.AddGate(gptr);
    }else{
        gptr = NameTable.get_value(name);
        gptr->SetFunction(G_NAND);
    }

}

// Function to process lines that have "input" in the 3rd field
void proc_input(const vector<string>& fields) {
    vector<string> inputs {};  
    vector<string> faults;

    if (fields.size() == 6){
        faults = {fields[5]};
    }else if (fields.size() == 7){
        faults = {fields[5], fields[6]}; 
    }else{
        cerr << "Erron to parse input gate Stuck_At_Fault" << endl;
        exit(EXIT_FAILURE);
    }


    //<net_id> <identifier> <gate_type> <fanout> <fanin> <faults>
    gptr = new GATE;
    int net_id = stoi(fields[0]);
    name = fields[1]; //gate name, should be unique
    if (!NameTable.is_member(name)){
        gptr->SetName(name);
        gptr->SetFunction(G_PI);
        gptr->Set_isc_net_id(net_id);    
        gptr->Set_isc_identifier(name);
        gptr->Set_isc_StuckAt(faults);
        gptr->Set_isc_fo_Cnt(stoi(fields[3]));
        gptr->Set_isc_fi_Cnt(stoi(fields[4])); //FI of G_PI should be 0

        NameTable.insert(name, gptr);
        Circuit.AddGate(gptr);
    }else{
        gptr = NameTable.get_value(name);
        gptr->SetFunction(G_PI);
    }
}

// Function to process lines that have "from" in the 3rd field
void proc_fan_from(const vector<string>& fields) {
    // vector<string> inputs ={fields[3]};  
    vector<string> faults;

    if (fields.size() == 5){
        faults = {fields[4]};
    }else{
        cerr << "Erron to parse Fan From Stuck_At_Fault" << endl;
        exit(EXIT_FAILURE);
    }


    //<net_id> <identifier> <gate_type> <fanout> <fanin> <faults>
    gptr = new GATE;
    int net_id = stoi(fields[0]);
    name = fields[1]; //gate name, should be unique
    if (!NameTable.is_member(name)){
        gptr->SetName(name);
        gptr->SetFunction(G_FROM);
        gptr->Set_isc_net_id(net_id);    
        gptr->Set_isc_identifier(name);
        gptr->Set_isc_StuckAt(faults);
        gptr->Set_isc_fo_Cnt(-1); // No Fan_IN, Fan_out for G_FROM.
        gptr->Set_isc_fi_Cnt(-1);
        gptr->AddInput_list(NameTable.get_value(fields[3]));

        NameTable.insert(name, gptr);
        Circuit.AddGate(gptr);
    }else{
        gptr = NameTable.get_value(name);
        gptr->SetFunction(G_FROM);
    }

}

// Function to process the file content stored in a string
void processBuffer(const string& buffer) {
    istringstream stream(buffer); // Create a string stream from the buffer
    string line;

    // Read and process the content line by line
    while (getline(stream, line)) {
        // Process each line (e.g., print it or parse it)
        cout << "Processing line: " << line << endl;
        // cout << "Debug: This is a debug message!" << endl;

        // Add your specific line processing logic here (e.g., tokenizing, searching, etc.)
        // Check if the line starts with '*', if so, skip it
        if (!line.empty() && line[0] == '*') {
            // cout << "Skipping line: " << line << endl;
            continue;  // Skip the rest of the loop for this line
        }

        // Split the line into fields (assumes space-delimited fields)
        istringstream lineStream(line);
        vector<string> fields;
        string field;
        while (lineStream >> field) {
            fields.push_back(field);  // Push each field into a vector
        }

        if (fields.size() < 4) { // At least 4 fileds.  14    14fan from    11gat
            cout << "Line: " << line << endl;
            cerr << "Not a gate. unexpected source file format, please check the source file." << endl;
            exit(EXIT_FAILURE); 
        }

        // Check if there are at least 3 fields and if the 3rd field is "nand"
        if (fields[2] == "nand") {
            // Get the next line from the buffer
            string next_line;
            if (getline(stream, next_line)) {
                // Pass the current line and next line to proc_nand
                proc_nand(fields, next_line);
            }
        }

        //process input 
        else if (fields[2] == "inpt") {
                proc_input(fields);
        }

        //process input 
        else if (fields[2] == "from") {
                proc_fan_from(fields);
        }

        else {
            cout << "Line: " << line << endl;
            cerr << "don't understand the line" << endl;
            exit(EXIT_FAILURE); 
        }




    } // end of while read the input
}// end of processBuffer




int parse_isc_main(const string& filename) {

    // Open the file
    ifstream inputFile(filename);
    if (!inputFile.is_open()) {
        cerr << "Error: Could not open file " << filename << endl;
        return 1;
    }

    // Read the file into a string
    string buffer((istreambuf_iterator<char>(inputFile)),
                       istreambuf_iterator<char>());

    inputFile.close(); // Close the file after reading

    // Pass the string buffer to the processing function
    processBuffer(buffer);

    // Add this line to pause the program
    cout << "Press Enter to continue..." << endl;
    cin.get();
    return 0;
}
